\section{Event Generation}

In order to understand the limits we want to impose on the parameters of our model, we must generate decay (or collision) events corresponding to each process which contributes to the final state.
This also requires that we simulate appropriate background processes which can masquerade as signal.
To achieve this, one has to integrate the square of the sum of each matrix element.
In some cases, such as kaon decay which we will compute later\improvement{when?}, this is possible to do by hand, at least in some approximation.
However, while the matrix elements are easy to write down, usually these processes can be quite tedious and very difficult to intergate.
For these cases, we will make use of \emph{event generators}, which effectively sample the allowed phase space of the matrix elements by Monte Carlo in order to perform the integration.

Our primary tools we use are \feynrules \cite{Alloul:2013bka}, \feyncalc \cite{Mertig:1990an}, and \mgamcnlo \cite{Alwall:2014hca}.
\feynrules allows one to easily write down a Lagrangian, and generate the Feynman rules dynamically.
For our purposes, the Feynman rules are easily seen directly from the Lagrangian.
However, the advantage of using \feynrules is that the output follows the Universal FeynRules Output (UFO) \cite{Degrande:2011ua}, and defining the model involves only writing some rather simple \mathematica code.
The UFO defines a portable format for a model, allowing multiple event generators to utilize its output.
Most important is that \madgraph can utilize the resulting model simply by putting the UFO model within the appropriate location within \madgraph.
\feyncalc is useful when assisting computations by hand, which is ultimately used for computing traces of many $\gamma$ matrices.

There are other tools that could further improve our limits which were not used: these include \pythia \cite{Sjostrand:2007gs}, which would handle the hard event generation instead of the generator provided by \madgraph, hadronization (which is not likely to be of use)\improvement{why not?}, initial and final state radion; and \delphes \cite{Selvaggi:2014mya}, providing a proper detector simulation at a level that is not as demanding as \geant \cite{Agostinelli}. For our purposes of simply estimating limits, these are for the most part not necessary.

\subsection{\feynrules}
\feynrules was developed as a toolkit to define new fields, write down a given model's Lagrangian, and automatically compute the Feynman rules.
The only requirements of the model are that the Lagrangian satisfy locality, Lorentz, and Gauge invariance, and allowable fields have spin 0, 1/2, 1, 3/2, or 2. The Lagrangian need not be an extension of the Standard Model, but simply any quantum field theory obeying the above requirements. 
It also will analytically compute simple decay widths for $1 \rightarrow 2$ processes, and branching ratios.
This toolkit works as a \mathematica package.

Within a \mathematica notebook, we simply write down the Lagrangian in terms of the fields, and request the Feynman rules be calculated and output to the UFO format, with the \texttt{WriteUFO[L + LSM]} command. Note that \feynrules contains the Standard Model Lagrangian already, so we simply need to append our new Lagrangian to this buitin one.
At the same time, we have \feynrules calculate the decay widths of each new particle, and update the model file with these using the calls to \texttt{vertices = FeynmanRules[L]}, \texttt{decays = ComputeWidths[vertices]}, and \texttt{UpdateWidths[decays]}.

Our model files for both the scalar and dark photon models are included in the appendix. \improvement[inline]{include fr in appendix}

\subsection{\feyncalc}
Only used minimally in this thesis, \feyncalc provides a quick sanity check for calculations done by hand.
