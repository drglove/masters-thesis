\section{Event Generation}

In order to understand the limits we want to impose on the parameters of our model, we must generate decay (or collision) events corresponding to each process which contributes to the final state.
This also requires that we simulate appropriate background processes which can masquerade as signal.
To achieve this, one has to integrate the square of the sum of each matrix element.
In some cases, such as kaon decay which we will compute later\improvement{when?}, this is possible to do by hand, at least in some approximation.
However, while the matrix elements are easy to write down, usually these processes can be quite tedious and very difficult to intergate.
For these cases, we will make use of \emph{event generators}, which effectively sample the allowed phase space of the matrix elements by Monte Carlo in order to perform the integration.

Our primary tools we use are \feynrules \cite{Alloul:2013bka}, \feyncalc \cite{Mertig:1990an}, and \mgamcnlo \cite{Alwall:2014hca}.
\feynrules allows one to easily write down a Lagrangian, and generate the Feynman rules dynamically.
For our purposes, the Feynman rules are easily seen directly from the Lagrangian.
However, the advantage of using \feynrules is that the output follows the Universal FeynRules Output (UFO) \cite{Degrande:2011ua}, and defining the model involves only writing some rather simple \mathematica code.
UFO defines a portable format for a model, allowing multiple event generators to utilize its output.
Most important is that \madgraph can utilize the resulting model simply by putting the UFO model within the appropriate location within \madgraph.
\feyncalc is useful when assisting computations by hand, which is ultimately used for computing traces of many $\gamma$ matrices.
